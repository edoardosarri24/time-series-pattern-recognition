\section{Sequential}

\begin{frame}{Sequential}
    \begin{block}{Data Loading}
        Il file di input può raggiungere grandi dimensioni ($\approx 3.5$ GB).
        \begin{itemize}
            \item \textbf{Problema:} Overhead \texttt{std::ifstream} (copie multiple, syscall).
            \item \textbf{Soluzione:} Memory Mapped I/O (\texttt{mmap}).
            \item \textbf{Ottimizzazione:} \texttt{madvise} con flag \texttt{MADV\_SEQUENTIAL} per indicare l'accesso lineare al kernel.
            \item \textbf{Risultato:} Parsing ridotto da $\approx 47s$ a $\approx 13s$.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Sequential}
    \begin{block}{Memory Layout - Array of Structures (AoS)}
        Struttura contigua per ogni timestamp: $[x_{1,1}, \dots, x_{1,D}, x_{2,1}, \dots]$.
        \begin{itemize}
            \item \textbf{Vantaggio:} Località spaziale ottimizzata per la sliding window.
            \item \textbf{Vectorization:} Uso di \texttt{-march=native} e keyword \texttt{restrict} per permettere al compilatore l'auto-vettorizzazione SIMD.
        \end{itemize}
    \end{block}
    \begin{block}{Padding}
        Allineamento dei dati alla cache line (64 Byte).
        \begin{itemize}
            \item Aggiunta di dimensioni fittizie per portare la dimensione del singolo timestamp a divisori di 64B.
            \item \textit{Nota:} L'analisi sperimentale ha mostrato che l'overhead di processare dati inutili supera i benefici dell'allineamento in questo caso specifico.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Sequential}
    \begin{block}{Algoritmo SAD}
        Brute Force Sliding Window.
        \[
        i^* = \arg\min_{i \in [0, N-M]} D(i)
        \]
    \end{block}
    \begin{block}{Early Abandoning}
        Interruzione del calcolo della distanza se la somma parziale supera il minimo globale corrente.
        \begin{itemize}
            \item \textbf{Speedup:} $\approx 2.87\times$ se attivato.
            \item \textbf{Baseline:} Disattivato per confronto equo ("apple-to-apple") con la versione GPU (dove la divergenza dei thread lo rende inefficace).
        \end{itemize}
    \end{block}
\end{frame}